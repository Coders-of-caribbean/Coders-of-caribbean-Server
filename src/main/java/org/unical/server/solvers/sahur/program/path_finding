cell(0..20, 0..22).
%--- Position utility ---%
%player(1,1,1,1,1).
%enemy(1,1,1,1,1).
%choose(1,1).
player_pos(X,Y) :- player(X,Y,_,_,_).
enemy_pos(X,Y) :- enemy(X,Y,_,_,_).


neighbors(cell(X1, Y1), cell(X,Y)) :- cell(X,Y), X=X1+1, Y=Y1. % Common
neighbors(cell(X1, Y1), cell(X,Y)) :- cell(X,Y), X=X1, Y=Y1-1. % Common
neighbors(cell(X1, Y1), cell(X,Y)) :- cell(X,Y), X=X1-1, Y=Y1. % Common
neighbors(cell(X1, Y1), cell(X,Y)) :- cell(X,Y), X=X1, Y=Y1+1. % Common
neighbors(cell(X1, Y1), cell(X,Y)) :- cell(X,Y), odd(Y1), X=X1+1, Y=Y1+1.
neighbors(cell(X1, Y1), cell(X,Y)) :- cell(X,Y), odd(Y1), X=X1+1, Y=Y1-1.
neighbors(cell(X1, Y1), cell(X,Y)) :- cell(X,Y), even(Y1), X=X1-1, Y=Y1+1.
neighbors(cell(X1, Y1), cell(X,Y)) :- cell(X,Y), even(Y1), X=X1-1, Y=Y1-1.

%---- Necessario per computare le celle ----%
odd(N) :-  cell(N,_), N2 = N / 2, N2*2 != N.
even(N) :- cell(N,_), not odd(N).

% https://github.com/CodinGame/coders-of-the-caribbean/blob/master/Referee.java
cube(XP,YP,ZP, cell(X,Y)) :- cell(X,Y), ZP=Y,  XP=X-(Y/2), even(Y), YP=-(XP+ZP).
cube(XP,YP,ZP, cell(X,Y)) :- cell(X,Y), ZP=Y,  XP=X-(Y-1)/2, odd(Y), YP=-(XP+ZP).

% Calcolo della distanza tra due celle diverse usando coordinate cubiche
distance(D, cell(X0,Y0), cell(X1,Y1)) :-
    cube(XP0, YP0, ZP0, cell(X0,Y0)),
    cube(XP1, YP1, ZP1, cell(X1,Y1)),
    &abs(XP0 - XP1; ADX),
    &abs(YP0 - YP1; ADY),
    &abs(ZP0 - ZP1; ADZ), D = (ADX + ADY + ADZ) / 2,choose(X1,Y1).

%--- Path finding made by nandus ---%
celle_visitabili(cell(-1,-1), cell(X,Y)) :- player_pos(X,Y).
in(cell(-1,-1), cell(X,Y)) :- player_pos(X,Y).

distanza_celle_adiacenti_dal_target(cell(X1,Y1), cell(X2,Y2), D_target) :-
                celle_visitabili(_, cell(X1,Y1)),
                neighbors(cell(X1,Y1), cell(X2, Y2)),
                distance(D_target, cell(X2,Y2), cell(XT,YT)), choose(XT,YT).

ePiuGrandeDiQualcuno(cell(X1,Y1), cell(X2,Y2)) :-
                distanza_celle_adiacenti_dal_target(cell(X1,Y1), cell(X2,Y2), D1),
                distanza_celle_adiacenti_dal_target(cell(X1,Y1), cell(XN2,YN2), D2),
                cell(X2,Y2)!=cell(XN2,YN2), D2<D1, not mine(XN2, YN2).

distanza_della_cella_adiacente_piu_vicina(cell(X1,Y1), Distance) :-
                distanza_celle_adiacenti_dal_target(cell(X1,Y1), cell(X,Y), Distance),
                not ePiuGrandeDiQualcuno(cell(X1,Y1), cell(X,Y)).

cella_adiacente_piu_vicina(cell(X1,Y1), cell(X2,Y2)) :-
                distanza_della_cella_adiacente_piu_vicina(cell(X1,Y1), Distance),
                distanza_celle_adiacenti_dal_target(cell(X1,Y1), cell(X2,Y2), Distance).

celle_visitabili(cell(X1,Y1), cell(X2,Y2)) :-
                cella_adiacente_piu_vicina(cell(X1,Y1), cell(X2,Y2)).

in(cell(X1,Y1), cell(X2,Y2)) | out(cell(X1,Y1), cell(X2,Y2)) :- celle_visitabili(cell(X1,Y1), cell(X2,Y2)).
in(cell(X1,Y1), cell(X2,Y2)) | out(cell(X1,Y1), cell(X2,Y2)) :- distanza_celle_adiacenti_dal_target(cell(X1,Y1), cell(X2,Y2), _).

%--- Constraint per avere dei nodi collegati tutti sempre tra loro (a coppie) ---%
ceAlmenoUnAdiacente(cell(X,Y)) :-
                in(_, cell(X,Y)), in(cell(X,Y), cell(X1,Y1)),
                distanza_celle_adiacenti_dal_target(cell(X,Y), cell(X1,Y1), _).

:-
    in(_, cell(X,Y)),
    not ceAlmenoUnAdiacente(cell(X,Y)),
    finaleIn(cell(XF,YF)),
    cell(X,Y) != cell(XF,YF).

%--- Constraint per evitare che la stessa cella ha due celle figlie diverse o due celle parent diverse ---%
:-
    in(cell(X1,Y1), cell(X,Y)),
    in(cell(X2,Y2), cell(X,Y)),
    cell(X1,Y1) != cell(X2,Y2).


:-
    in(cell(X,Y), cell(X1,Y1)),
    in(cell(X,Y), cell(X2,Y2)),
    cell(X1,Y1)!=cell(X2,Y2).

%--- Constraints per decidere se Ã¨ meglio prendere una mina e camminare poco o camminare tanto ma senza prendere mine ---%
:~ mine(X,Y), in(_, cell(X,Y)). [1@2] % cerca di prendere il minor numero di mine possibili
:~ in(_,C). [1@1,C] % minimizza il cammino

%--- Constraint che stabilisce che la cella finale sia una cella adiacente alla cella del NearestRum ---%
finaleIn(cell(X,Y)) :- in(_, cell(X,Y)), choose(XR,YR), neighbors(cell(X,Y), cell(XR,YR)).
:- #count{A : finaleIn(A)} != 1.

exists_move :- #count{X,Y : move(_,X,Y)} >= 1.
move(1, X, Y) :- in(cell(X1,Y1), cell(X,Y)), player_pos(X1,Y1).
move(1, X, Y) :- choose(X,Y), not exists_move.

#show move/3.