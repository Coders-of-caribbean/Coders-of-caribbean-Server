cell(0..20, 0..22).

%--- Debug zone ---%
%player(1,2,100,1,1).
%enemy(1,1,100,1,1).
%rum(2,0,15).
%rum(20,20,26).

%--- Life utility ---%
more_life_than(enemy_pos(X,Y)) :- enemy(X,Y, H_theirs,_,_), player(_,_,H_ours,_,_), H_ours/2>H_theirs, H_theirs != 0.
less_life_than(enemy_pos(X,Y)) :- enemy(X,Y, H_theirs,_,_), player(_,_,H_ours,_,_), H_ours<H_theirs.
need_rum :- player(_,_,X,_,_), X <= 20.

%--- Position utility ---%
player_pos(X,Y) :- player(X,Y,_,_,_).
enemy_pos(X,Y) :- enemy(X,Y,_,_,_).



% Compute distance è un flag che serve per attivare la regola della conversione in coordinate cubiche
% Una volta effettuata la conversione verranno espansi i predicati delle distanze
% Verranno calcolate le distanze tra ogni predicato presente in compute_distance.
compute_distance(cell(X,Y)) :- rum(X,Y, _).
compute_distance(cell(X,Y)) :- player_pos(X,Y).
compute_distance(cell(X,Y)) :- enemy_pos(X,Y).

%---- Necessario per computare le celle ----%
odd(N) :-  cell(N,_), N2 = N / 2, N2*2 != N.
even(N) :- cell(N,_), not odd(N).


% https://github.com/CodinGame/coders-of-the-caribbean/blob/master/Referee.java
cube(XP,YP,ZP, cell(X,Y)) :- cell(X,Y), ZP=Y,  XP=X-(Y/2), even(Y), YP=-(XP+ZP), compute_distance(cell(X,Y)).
cube(XP,YP,ZP, cell(X,Y)) :- cell(X,Y), ZP=Y,  XP=X-(Y-1)/2, odd(Y), YP=-(XP+ZP), compute_distance(cell(X,Y)).

% Per chiarire le idee.
% rum(6,5). % Colonna 6 (X), Riga 5 (Y).

cube_subtraction(DX, DY, DZ, cell(X0, Y0), cell(X1, Y1)) :-
    cube(X0C, Y0C, Z0C, cell(X0, Y0)),
    cube(X1C, Y1C, Z1C, cell(X1, Y1)),
    DX = X0C - X1C,
    DY = Y0C - Y1C,
    DZ = Z0C - Z1C,
    cell(X0, Y0) != cell(X1, Y1). % Scarto il calcolo della distanza tra celle identiche

abs_cube(ADX, cell(X0,Y0), cell(X1,Y1)) :- cube_subtraction(DX, _, _, cell(X0,Y0), cell(X1,Y1)), &abs(DX; ADX).
abs_cube(ADY, cell(X0,Y0), cell(X1,Y1)) :- cube_subtraction(_, DY, _, cell(X0,Y0), cell(X1,Y1)), &abs(DY; ADY).
abs_cube(ADZ, cell(X0,Y0), cell(X1,Y1)) :- cube_subtraction(_, _, DZ, cell(X0,Y0), cell(X1,Y1)), &abs(DZ; ADZ).

distance(D, cell(X0,Y0), cell(X1,Y1)) :-
    cube_subtraction(_, _, _, cell(X0,Y0), cell(X1,Y1)),
    D = #max{AD: abs_cube(AD, cell(X0, Y0), cell(X1, Y1))}.


%--- nearest rum for player/enemy ---%
nearest_rum(player_pos(X,Y), cell(X1,Y1), Distance) :-
                                                    player_pos(X,Y),
                                                    distance(Distance, cell(X,Y), cell(X1,Y1)), rum(X1,Y1,_),
                                                    Distance = #min{D : distance(D, cell(X,Y), cell(X0,Y0)), rum(X0,Y0,_)}.

nearest_rum(enemy_pos(X,Y), cell(X1,Y1), Distance) :-
                                                    enemy_pos(X,Y),
                                                    distance(Distance, cell(X,Y), cell(X1,Y1)), rum(X1,Y1,_),
                                                    Distance = #min{D : distance(D, cell(X,Y), cell(X0,Y0)), rum(X0,Y0,_)}.

%--- best rum for player/enemy ---%
% best rum mean nearest rum with max quantity
best_nearest(player_pos(X,Y), rum(X1,Y1, Quantity)) :-
                                                    nearest_rum(player_pos(X,Y), cell(X1,Y1), _), rum(X1,Y1, Quantity),
                                                    Quantity = #max{Q : nearest_rum(player_pos(X,Y), cell(X0,Y0), _), rum(X0,Y0,Q)}.

best_nearest(enemy_pos(X,Y), rum(X1,Y1, Quantity)) :-
                                                    nearest_rum(enemy_pos(X,Y), cell(X1,Y1), _), rum(X1,Y1, Quantity),
                                                    Quantity = #max{Q : nearest_rum(enemy_pos(X,Y), cell(X0,Y0), _), rum(X0,Y0,Q)}.

nearest_enemy(enemy_pos(EX,EY), Distance) :-
                                        player_pos(X,Y),
                                        distance(Distance, cell(X,Y), cell(EX,EY)), enemy_pos(EX,EY),
                                        Distance = #min{D : distance(D, cell(EX1,EY1), cell(PX,PY)), enemy_pos(EX1,EY1)}.


unsafe(cell(X,Y)) :- nearest_rum(player_pos(PX,PY), cell(X,Y),_), nearest_rum(enemy_pos(EX, EY), cell(X,Y) ,_).
choose(X,Y) | not_choosen(X,Y) :- best_nearest(player_pos(_,_), rum(X,Y,_)).

:~ action_rum. [2@1]
:~ choose(X,Y), nearest_enemy(enemy_pos(X,Y), D_enemy), nearest_rum(player_pos(_,_), cell(X1,Y1), D_rum), D_enemy=1. [10@1]


move(1, X,Y) :- choose(X,Y).

:- #count{X,Y : choose(X,Y)} != 1.

%#show choose/2.
%#show speed/0.
%#show speed_required/1.
%#show best_nearest/2.
#show action_attack/0.
%#show nearest_rum/3.
#show action_rum/0.
%#show life/0.
%#show nearest_rum/3.
%#show nearest_enemy/2.
#show move/3.
%
%speed(cell(X,Y)) :- cell(X,Y),
%                     nearest_rum(player_pos(G1, G2), cell(X,Y), D1),
%                     nearest_rum(enemy_pos(G3,G4), cell(X,Y), D2),
%                     enemy(G3,G4, _, 2, _), % Il nemico ha la speed attiva
%                     D1 = D2/2. % Con la speed attiva arriverà quando arriveremo noi => può avvenire una collisione => per evitarla dobbiamo attivare la speed

%unsafe(cell(X,Y)) :- cell(X,Y),
%                     nearest_rum(player_pos(G1, G2), cell(X,Y), D1),
%                     nearest_rum(enemy_pos(G3,G4), cell(X,Y), D2),
%                     enemy(G3,G4, _, 1, _), % Il nemico non ha la speed attiva
%                     D1 > D2/2, % Se attivasse la speed arriverebbe prima di noi
%                     D1/2 > D2/2, % Se attiviamo la speed lui comunque arriverebbe prima di noi
%
%
% 

%speed :- nearest_rum(player_pos(_,_), cell(X,Y), D_ours),
%                        nearest_rum(enemy_pos(_,_), cell(X,Y), D_theirs),
%                        D_ours/2 > D_theirs;